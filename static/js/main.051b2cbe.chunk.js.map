{"version":3,"sources":["App.jsx","index.js"],"names":["sdk","ThirdwebSDK","bundleDropModule","getBundleDropModule","tokenModule","getTokenModule","voteModule","getVoteModule","App","useWeb3","connectWallet","address","error","provider","console","log","signer","getSigner","undefined","useState","hasClaimedNFT","setHasClaimedNFT","isClaiming","setIsClaiming","memberTokenAmounts","setMemberTokenAmounts","memberAddresses","setMemberAddresses","proposals","setProposals","isVoting","setIsVoting","hasVoted","setHasVoted","useEffect","a","getAll","length","proposalId","getAllClaimerAddresses","getAllHolderBalances","amounts","memberList","useMemo","map","tokenAmount","ethers","utils","formatUnits","setProviderOrSigner","balanceOf","balance","gt","UnsupportedChainIdError","className","onClick","mintNft","claim","alert","member","str","substring","onSubmit","e","preventDefault","stopPropagation","votes","proposal","voteResult","vote","forEach","document","getElementById","type","checked","getDelegationOf","delegation","constants","AddressZero","delegateTo","Promise","all","get","state","execute","description","id","name","value","defaultChecked","for","label","disabled","ReactDOM","render","StrictMode","connectors","injected","supportedChainIds"],"mappings":"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","file":"static/js/main.051b2cbe.chunk.js","sourcesContent":["import {useEffect, useMemo, useState} from \"react\";\nimport {ThirdwebSDK} from \"@3rdweb/sdk\";\nimport {useWeb3} from \"@3rdweb/hooks\";\nimport {ethers} from \"ethers\";\nimport {UnsupportedChainIdError} from '@web3-react/core';\n\n//inisiate the sdk on Rinkeby\nconst sdk = new ThirdwebSDK(\"rinkeby\");\n\n// We can grab a reference to our ERC-1155 contract\nconst bundleDropModule = sdk.getBundleDropModule(\n  \"0xEaDAb6d179A9c0DB0D4A20F08296D1Ac77a2A99a\",\n);\n\nconst tokenModule = sdk.getTokenModule(\n  \"0xf4552FD2ac882D3fF36e7b1D8632f90E741cc88D\",\n);\n\nconst voteModule = sdk.getVoteModule(\n  \"0xDd45fafeC0dEbF26c55f343AA4192DE0762485e6\"\n);\n\nconst App = () => {\n  //use the connectWallet hook thirdweb gives us.\n  const {connectWallet,address, error, provider} = useWeb3();\n  console.log(\"Address:\", address);\n\n  //The signer is required to sign transaction on the blockchain.\n  //Without it we can only read data, not write.\n  const signer = provider? provider.getSigner(): undefined;\n  \n  //state to define user has our NFT or not\n  const [hasClaimedNFT, setHasClaimedNFT] = useState(false);\n  //isClaiming lets us easily keep a loading state while the NFT is minting.\n  const [isClaiming, setIsClaiming] = useState(false);\n  //Hold the amoun of token each member has in state.\n  const [memberTokenAmounts, setMemberTokenAmounts] = useState({});\n  //the array holding all our members addresses\n  const [memberAddresses, setMemberAddresses] = useState([]);\n\n  const [proposals, setProposals] = useState([]);\n  const [isVoting, setIsVoting] = useState(false);\n  const [hasVoted, setHasVoted] = useState(false);\n\n  //Retrieve all our existing proposals from the contract\n  useEffect(async()=>{\n    if(!hasClaimedNFT){\n      return;\n    }\n    // A simple call to voteModule.getAll() to grab the proposals.\n    try {\n      const proposals = await voteModule.getAll();\n      setProposals(proposals);\n      console.log(\"Proposals:\",proposals);\n    } catch(error){\n      console.log(\"failed to get proposal\", error);\n    }\n  },[hasClaimedNFT]);\n\n  //check if user already voted\n  useEffect(async()=>{\n    if(!hasClaimedNFT){\n      return;\n    }\n\n    //If we haven't finished retrieving the proposals fromthe useEffect above \n    // then we can't check if the user voted yet!\n    if(!proposals.length){\n      return;\n    }\n\n    //Check if the user hasalready voted on the first proposal.\n    try{\n      const hasVoted = await voteModule.hasVoted(proposals[0].proposalId,address);\n      setHasVoted(hasVoted);\n      if(hasVoted){\n        console.log(\"User has already voted\");\n        \n      }else {\n        console.log(\"User has not voted yet\")\n      }\n    } catch(error){\n      console.error(\"Failed to check if wallet has voted\", error);\n    }\n  }, [hasClaimedNFT, proposals, address])\n\n  // A fancy function to shorten someones wallet address\n  const shortenAddress = (str) =>{\n    return str.substring(0,6) + \"...\" + str.substring(str.length - 4);\n  };\n\n  // This useEffect grabs all the addresses of our members holding our NFT.\n  useEffect(async()=>{\n    if (!hasClaimedNFT){\n      return;\n    }\n\n    //Grab the users who hold NFT with tokenId 0\n    try{\n      const memberAddresses = await bundleDropModule.getAllClaimerAddresses(\"0\")\n      setMemberAddresses(memberAddresses);\n      console.log(\"Members addresses\", memberAddresses);\n    } catch(error){\n      console.error(\"failed to get member list\", error);\n    }\n  },[hasClaimedNFT])\n\n  useEffect(async()=>{\n    if(!hasClaimedNFT){\n      return;\n    }\n\n    //Grab all the balance \n    try{\n      const amounts = await tokenModule.getAllHolderBalances();\n      setMemberTokenAmounts(amounts);\n      console.log(\"Amounts\", amounts);\n    } catch(error){\n      console.error(\"failed to get token amounts\", error);\n    }\n  },[hasClaimedNFT]);\n\n  const memberList = useMemo(()=>{\n    return memberAddresses.map((address)=>{\n      return {\n        address,\n        tokenAmount : ethers.utils.formatUnits(\n          //If the address isn't in memberTokenAmount, it means they\n          //don't hold any of our token\n          memberTokenAmounts[address] || 0,\n          18\n        ),\n      };\n    });\n  },[memberAddresses, memberTokenAmounts]);\n  \n  //Another useEffect!\n  useEffect(()=>{\n    //pass the signer to the SDK\n    //enables us to interact with our deployed contract!\n    sdk.setProviderOrSigner(signer);\n  },[signer])\n\n  useEffect(async()=>{\n    if (!address){\n      return;\n    }\n\n    //Check if the user has the NFT using bundleDropModule.BalanceOf\n    const balance = await bundleDropModule.balanceOf(address,\"0\");\n\n    try{\n      //if balance greater than 0, they have our NFT!\n      if (balance.gt(0)){\n        setHasClaimedNFT(true);\n        console.log(\"This user has a membership NFT!\");\n      } else {\n        setHasClaimedNFT(false);\n        console.log(\"this user doesn't have a membership NFT.\");\n      }\n    } catch(error){\n      setHasClaimedNFT(false);\n      console.error(\"failed to nft balance\", error);\n    }\n  }, [address]);\n\n  if(error instanceof UnsupportedChainIdError){\n    return (\n      <div className=\"unsupported-network\">\n        <h2>Please connect to Rinkeby</h2>\n        <p>\n          This dapp only works on the Rinkeby network, please switch networks in your connected wallet!\n        </p>\n      </div>\n    );\n  }\n\n\n  \n  //this is the case user hasn't connected their wallet\n  // to your web app. let them call connectWallet\n  if(!address){\n    return (\n      <div className=\"landing\">\n        <h1>Welcome to ProjectGDAO</h1>\n        <button onClick={()=> connectWallet(\"injected\")} className=\"btn-hero\">\n          Connect your wallet\n        </button>\n      </div>\n    )\n  }\n\n  const mintNft= async()=>{\n    setIsClaiming(true);\n    try{\n      // Call bundleDropModule.claim(\"0\",1) to mint nft to user's wallet.\n      await bundleDropModule.claim(\"0\",1);\n      //set claim state\n      setHasClaimedNFT(true);\n      //show user their fance new NFT\n      alert(`Successfully Minted! check itout on OpenSea: https://testnets.opensea.io/assets/${bundleDropModule.address}/0`)\n    }catch(error){\n      console.error(\"Failed to claim\", error);\n    } finally{\n      setIsClaiming(false);\n    }\n  }\n\n  //if the user has already claimed their NFT we want to display the internal\n  //DAO, only DAO member will see this. Render all the members + token amounts.\n  if(hasClaimedNFT){\n    return(\n      <div className=\"member-page\">\n        <h1>DAO member page</h1>\n        <p>Congratulations on being a member</p>\n        <div>\n          <div>\n            <h2> Member List</h2>\n            <table className=\"card\">\n              <thead>\n                <tr>\n                  <th>Address</th>\n                  <th>Token Amount</th>\n                </tr>\n              </thead>\n              <tbody>\n                {memberList.map((member)=>{\n                  return(\n                    <tr key={member.address}>\n                      <td>{shortenAddress(member.address)}</td>\n                      <td>{member.tokenAmount}</td>\n                    </tr>\n                  );\n                })}\n              </tbody>\n            </table>\n          </div>\n        \n        \n          <div>\n            <h2> Active Proposals </h2>\n            <form onSubmit={\n              async(e)=>{\n                e.preventDefault();\n                e.stopPropagation();\n\n                setIsVoting(true);\n\n                const votes = proposals.map((proposal)=>{\n                  let voteResult = {\n                    proposalId: proposal.proposalId,\n                    //abstain by default\n                    vote : 2,\n                  }\n                  proposal.votes.forEach((vote)=>{\n                    const elem = document.getElementById(\n                      proposal.proposalId+'-'+vote.type\n                    )\n                    if (elem.checked){\n                      voteResult.vote = vote.type;\n                      return;\n                    }\n                  })\n                  return voteResult;\n                });\n\n                //first we need to make sure the user delegates their token to vote\n                try{\n                  const delegation = await tokenModule.getDelegationOf(address);\n                  //if the delegaion is the 0x0 that means they have note delegated their governance tokens yet\n                  if (delegation === ethers.constants.AddressZero){\n                    //if they havent delegated their token yet, we'll have them before voting\n                    await tokenModule.delegateTo(address);\n                  }\n                  console.log(delegation);\n                  console.log(votes)\n                  //then we need to vote on the proposals\n                  try {\n                    await Promise.all(\n                      votes.map(async(vote)=>{\n                        //before voting we first need to check whether the proposal is open for voting\n                        //we first need to get the latest state of the proposal\n                        const proposal = await voteModule.get(vote.proposalId);\n                        console.log(proposal);\n                        console.log(vote.vote);\n                        //then we check if the proposal is open for voting (state === 1 means it is open)\n                        if( proposal.state === 1){\n                          return voteModule.vote(vote.proposalId,vote.vote)\n                        }\n                        //if proposal is not open for voting we just return nothing\n                        return;\n                      })\n                    );\n                    try{\n                      //if any of the proposals are ready to be executed we'll need to execute them\n                      //a proposal isready to be executed if it is in state 4\n                      await Promise.all(\n                        votes.map(async(vote)=>{\n                          const proposal = await voteModule.get(\n                            vote.proposalId\n                          );\n\n                          //if the state is in state 4, we'll execute \n                          if (proposal.state === 4){\n                            return voteModule.execute(vote.proposalId);\n                          }\n                        })\n                      );\n                      // if we get here that means we succesfully voted, so let's set the \"hasVoted\" status\n                      setHasVoted(true);\n                      console.log(\"successfully voted\");\n                    } catch (error){\n                      console.error(\"failed to execute votes\", error);\n                    }\n                  } catch(err){\n                    console.error(\"failed to vote\", err);\n                  }\n                } catch (err){\n                  console.error(\"failed to delegate tokens\");\n                } finally {\n                  setIsVoting(false);\n                }\n              }\n            }>\n            {proposals.map((proposal)=>{\n              return(\n                <div className=\"card\">\n                  <h5> {proposal.description}</h5>\n                  {proposal.votes.map((vote)=>{\n                  return(\n                    <div key={vote.type}>\n                      <input \n                        type=\"radio\" \n                        id={proposal.proposalId + \"-\"+ vote.type}\n                        name={proposal.proposalId}\n                        value={vote.type}\n                        defaultChecked= {vote.type === 2}/>\n                      <label \n                        for={vote.label}>\n                        {vote.label}\n                      </label>\n                    </div>\n                  )})}\n                </div>\n              )\n            })}\n              <button disabled={isVoting || hasVoted} type=\"submit\">\n                {isVoting \n                  ? \"Voting...\"\n                  : hasVoted \n                    ? \"You Already voted\"\n                    : \"Submit Votes\"\n                }\n              </button>\n              <small>\n                This will trigger multiple transactions that you will need to sign.\n              </small>\n            </form>\n          </div>\n        </div>\n      </div>\n      \n    \n    );\n  };\n  \n  //this is the case where we have the user address\n  // which means they've connected their wallet to our site!\n  \n  return (\n    <div className=\"mint-nft\">\n      <h1>Mint Your free DAO Membership NFT</h1>\n      <button disabled={isClaiming} onClick={()=>mintNft()}>\n        {isClaiming? \"Minting...\" : \"Mint your nft (FREE)\"}\n      </button>\n    </div>\n  );\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App.jsx\";\n\n//import 3rdWeb\nimport {ThirdwebWeb3Provider} from '@3rdweb/hooks';\n\n//Included Chain You wanna support\n//Rinkeby Chain Id = 4\nconst supportedChainIds = [4];\n\n//included what type wallet you wanna support\n//in this case metamask is injected wallet\nconst connectors = {\n  injected:{},\n}\n// Render the App component to the DOM\nReactDOM.render(\n  <React.StrictMode>\n    <ThirdwebWeb3Provider \n      connectors = {connectors}\n      supportedChainIds = {supportedChainIds}\n    >\n      <App />\n    </ThirdwebWeb3Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}